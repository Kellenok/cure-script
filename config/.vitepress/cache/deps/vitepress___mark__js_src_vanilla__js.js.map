{
  "version": 3,
  "sources": ["../../../../node_modules/mark.js/src/lib/domiterator.js", "../../../../node_modules/mark.js/src/lib/mark.js", "../../../../node_modules/mark.js/src/vanilla.js"],
  "sourcesContent": ["/**\r\n * A NodeIterator with iframes support and a method to check if an element is\r\n * matching a specified selector\r\n * @example\r\n * const iterator = new DOMIterator(\r\n *     document.querySelector(\"#context\"), true\r\n * );\r\n * iterator.forEachNode(NodeFilter.SHOW_TEXT, node => {\r\n *     console.log(node);\r\n * }, node => {\r\n *     if(DOMIterator.matches(node.parentNode, \".ignore\")){\r\n *         return NodeFilter.FILTER_REJECT;\r\n *     } else {\r\n *         return NodeFilter.FILTER_ACCEPT;\r\n *     }\r\n * }, () => {\r\n *     console.log(\"DONE\");\r\n * });\r\n * @todo Outsource into separate repository\r\n */\r\nexport default class DOMIterator {\r\n\r\n  /**\r\n   * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM\r\n   * element, an array of DOM elements, a NodeList or a selector\r\n   * @param {boolean} [iframes=true] - A boolean indicating if iframes should\r\n   * be handled\r\n   * @param {string[]} [exclude=[]] - An array containing exclusion selectors\r\n   * for iframes\r\n   * @param {number} [iframesTimeout=5000] - A number indicating the ms to\r\n   * wait before an iframe should be skipped, in case the load event isn't\r\n   * fired. This also applies if the user is offline and the resource of the\r\n   * iframe is online (either by the browsers \"offline\" mode or because\r\n   * there's no internet connection)\r\n   */\r\n  constructor(ctx, iframes = true, exclude = [], iframesTimeout = 5000) {\r\n    /**\r\n     * The context of the instance. Either a DOM element, an array of DOM\r\n     * elements, a NodeList or a selector\r\n     * @type {HTMLElement|HTMLElement[]|NodeList|string}\r\n     * @access protected\r\n     */\r\n    this.ctx = ctx;\r\n    /**\r\n     * Boolean indicating if iframe support is enabled\r\n     * @type {boolean}\r\n     * @access protected\r\n     */\r\n    this.iframes = iframes;\r\n    /**\r\n     * An array containing exclusion selectors for iframes\r\n     * @type {string[]}\r\n     */\r\n    this.exclude = exclude;\r\n    /**\r\n     * The maximum ms to wait for a load event before skipping an iframe\r\n     * @type {number}\r\n     */\r\n    this.iframesTimeout = iframesTimeout;\r\n  }\r\n\r\n  /**\r\n   * Checks if the specified DOM element matches the selector\r\n   * @param  {HTMLElement} element - The DOM element\r\n   * @param  {string|string[]} selector - The selector or an array with\r\n   * selectors\r\n   * @return {boolean}\r\n   * @access public\r\n   */\r\n  static matches(element, selector) {\r\n    const selectors = typeof selector === 'string' ? [selector] : selector,\r\n      fn = (\r\n        element.matches ||\r\n        element.matchesSelector ||\r\n        element.msMatchesSelector ||\r\n        element.mozMatchesSelector ||\r\n        element.oMatchesSelector ||\r\n        element.webkitMatchesSelector\r\n      );\r\n    if (fn) {\r\n      let match = false;\r\n      selectors.every(sel => {\r\n        if (fn.call(element, sel)) {\r\n          match = true;\r\n          return false;\r\n        }\r\n        return true;\r\n      });\r\n      return match;\r\n    } else { // may be false e.g. when el is a textNode\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns all contexts filtered by duplicates (even nested)\r\n   * @return {HTMLElement[]} - An array containing DOM contexts\r\n   * @access protected\r\n   */\r\n  getContexts() {\r\n    let ctx,\r\n      filteredCtx = [];\r\n    if (typeof this.ctx === 'undefined' || !this.ctx) { // e.g. null\r\n      ctx = [];\r\n    } else if (NodeList.prototype.isPrototypeOf(this.ctx)) {\r\n      ctx = Array.prototype.slice.call(this.ctx);\r\n    } else if (Array.isArray(this.ctx)) {\r\n      ctx = this.ctx;\r\n    } else if (typeof this.ctx === 'string') {\r\n      ctx = Array.prototype.slice.call(\r\n        document.querySelectorAll(this.ctx)\r\n      );\r\n    } else { // e.g. HTMLElement or element inside iframe\r\n      ctx = [this.ctx];\r\n    }\r\n    // filter duplicate text nodes\r\n    ctx.forEach(ctx => {\r\n      const isDescendant = filteredCtx.filter(contexts => {\r\n        return contexts.contains(ctx);\r\n      }).length > 0;\r\n      if (filteredCtx.indexOf(ctx) === -1 && !isDescendant) {\r\n        filteredCtx.push(ctx);\r\n      }\r\n    });\r\n    return filteredCtx;\r\n  }\r\n\r\n  /**\r\n   * @callback DOMIterator~getIframeContentsSuccessCallback\r\n   * @param {HTMLDocument} contents - The contentDocument of the iframe\r\n   */\r\n  /**\r\n   * Calls the success callback function with the iframe document. If it can't\r\n   * be accessed it calls the error callback function\r\n   * @param {HTMLElement} ifr - The iframe DOM element\r\n   * @param {DOMIterator~getIframeContentsSuccessCallback} successFn\r\n   * @param {function} [errorFn]\r\n   * @access protected\r\n   */\r\n  getIframeContents(ifr, successFn, errorFn = () => {}) {\r\n    let doc;\r\n    try {\r\n      const ifrWin = ifr.contentWindow;\r\n      doc = ifrWin.document;\r\n      if (!ifrWin || !doc) { // no permission = null. Undefined in Phantom\r\n        throw new Error('iframe inaccessible');\r\n      }\r\n    } catch (e) {\r\n      errorFn();\r\n    }\r\n    if (doc) {\r\n      successFn(doc);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if an iframe is empty (if about:blank is the shown page)\r\n   * @param {HTMLElement} ifr - The iframe DOM element\r\n   * @return {boolean}\r\n   * @access protected\r\n   */\r\n  isIframeBlank(ifr) {\r\n    const bl = 'about:blank',\r\n      src = ifr.getAttribute('src').trim(),\r\n      href = ifr.contentWindow.location.href;\r\n    return href === bl && src !== bl && src;\r\n  }\r\n\r\n  /**\r\n   * Observes the onload event of an iframe and calls the success callback or\r\n   * the error callback if the iframe is inaccessible. If the event isn't\r\n   * fired within the specified {@link DOMIterator#iframesTimeout}, then it'll\r\n   * call the error callback too\r\n   * @param {HTMLElement} ifr - The iframe DOM element\r\n   * @param {DOMIterator~getIframeContentsSuccessCallback} successFn\r\n   * @param {function} errorFn\r\n   * @access protected\r\n   */\r\n  observeIframeLoad(ifr, successFn, errorFn) {\r\n    let called = false,\r\n      tout = null;\r\n    const listener = () => {\r\n      if (called) {\r\n        return;\r\n      }\r\n      called = true;\r\n      clearTimeout(tout);\r\n      try {\r\n        if (!this.isIframeBlank(ifr)) {\r\n          ifr.removeEventListener('load', listener);\r\n          this.getIframeContents(ifr, successFn, errorFn);\r\n        }\r\n      } catch (e) { // isIframeBlank maybe throws throws an error\r\n        errorFn();\r\n      }\r\n    };\r\n    ifr.addEventListener('load', listener);\r\n    tout = setTimeout(listener, this.iframesTimeout);\r\n  }\r\n\r\n  /**\r\n   * Callback when the iframe is ready\r\n   * @callback DOMIterator~onIframeReadySuccessCallback\r\n   * @param {HTMLDocument} contents - The contentDocument of the iframe\r\n   */\r\n  /**\r\n   * Callback if the iframe can't be accessed\r\n   * @callback DOMIterator~onIframeReadyErrorCallback\r\n   */\r\n  /**\r\n   * Calls the callback if the specified iframe is ready for DOM access\r\n   * @param  {HTMLElement} ifr - The iframe DOM element\r\n   * @param  {DOMIterator~onIframeReadySuccessCallback} successFn - Success\r\n   * callback\r\n   * @param {DOMIterator~onIframeReadyErrorCallback} errorFn - Error callback\r\n   * @see {@link http://stackoverflow.com/a/36155560/3894981} for\r\n   * background information\r\n   * @access protected\r\n   */\r\n  onIframeReady(ifr, successFn, errorFn) {\r\n    try {\r\n      if (ifr.contentWindow.document.readyState === 'complete') {\r\n        if (this.isIframeBlank(ifr)) {\r\n          this.observeIframeLoad(ifr, successFn, errorFn);\r\n        } else {\r\n          this.getIframeContents(ifr, successFn, errorFn);\r\n        }\r\n      } else {\r\n        this.observeIframeLoad(ifr, successFn, errorFn);\r\n      }\r\n    } catch (e) { // accessing document failed\r\n      errorFn();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback when all iframes are ready for DOM access\r\n   * @callback DOMIterator~waitForIframesDoneCallback\r\n   */\r\n  /**\r\n   * Iterates over all iframes and calls the done callback when all of them\r\n   * are ready for DOM access (including nested ones)\r\n   * @param {HTMLElement} ctx - The context DOM element\r\n   * @param {DOMIterator~waitForIframesDoneCallback} done - Done callback\r\n   */\r\n  waitForIframes(ctx, done) {\r\n    let eachCalled = 0;\r\n    this.forEachIframe(ctx, () => true, ifr => {\r\n      eachCalled++;\r\n      this.waitForIframes(ifr.querySelector('html'), () => {\r\n        if (!(--eachCalled)) {\r\n          done();\r\n        }\r\n      });\r\n    }, handled => {\r\n      if (!handled) {\r\n        done();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Callback allowing to filter an iframe. Must return true when the element\r\n   * should remain, otherwise false\r\n   * @callback DOMIterator~forEachIframeFilterCallback\r\n   * @param {HTMLElement} iframe - The iframe DOM element\r\n   */\r\n  /**\r\n   * Callback for each iframe content\r\n   * @callback DOMIterator~forEachIframeEachCallback\r\n   * @param {HTMLElement} content - The iframe document\r\n   */\r\n  /**\r\n   * Callback if all iframes inside the context were handled\r\n   * @callback DOMIterator~forEachIframeEndCallback\r\n   * @param {number} handled - The number of handled iframes (those who\r\n   * wheren't filtered)\r\n   */\r\n  /**\r\n   * Iterates over all iframes inside the specified context and calls the\r\n   * callbacks when they're ready. Filters iframes based on the instance\r\n   * exclusion selectors\r\n   * @param {HTMLElement} ctx - The context DOM element\r\n   * @param {DOMIterator~forEachIframeFilterCallback} filter - Filter callback\r\n   * @param {DOMIterator~forEachIframeEachCallback} each - Each callback\r\n   * @param {DOMIterator~forEachIframeEndCallback} [end] - End callback\r\n   * @access protected\r\n   */\r\n  forEachIframe(ctx, filter, each, end = () => {}) {\r\n    let ifr = ctx.querySelectorAll('iframe'),\r\n      open = ifr.length,\r\n      handled = 0;\r\n    ifr = Array.prototype.slice.call(ifr);\r\n    const checkEnd = () => {\r\n      if (--open <= 0) {\r\n        end(handled);\r\n      }\r\n    };\r\n    if (!open) {\r\n      checkEnd();\r\n    }\r\n    ifr.forEach(ifr => {\r\n      if (DOMIterator.matches(ifr, this.exclude)) {\r\n        checkEnd();\r\n      } else {\r\n        this.onIframeReady(ifr, con => {\r\n          if (filter(ifr)) {\r\n            handled++;\r\n            each(con);\r\n          }\r\n          checkEnd();\r\n        }, checkEnd);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a NodeIterator on the specified context\r\n   * @see {@link https://developer.mozilla.org/en/docs/Web/API/NodeIterator}\r\n   * @param {HTMLElement} ctx - The context DOM element\r\n   * @param {DOMIterator~whatToShow} whatToShow\r\n   * @param {DOMIterator~filterCb} filter\r\n   * @return {NodeIterator}\r\n   * @access protected\r\n   */\r\n  createIterator(ctx, whatToShow, filter) {\r\n    return document.createNodeIterator(ctx, whatToShow, filter, false);\r\n  }\r\n\r\n  /**\r\n   * Creates an instance of DOMIterator in an iframe\r\n   * @param {HTMLDocument} contents - Iframe document\r\n   * @return {DOMIterator}\r\n   * @access protected\r\n   */\r\n  createInstanceOnIframe(contents) {\r\n    return new DOMIterator(contents.querySelector('html'), this.iframes);\r\n  }\r\n\r\n  /**\r\n   * Checks if an iframe occurs between two nodes, more specifically if an\r\n   * iframe occurs before the specified node and after the specified prevNode\r\n   * @param {HTMLElement} node - The node that should occur after the iframe\r\n   * @param {HTMLElement} prevNode - The node that should occur before the\r\n   * iframe\r\n   * @param {HTMLElement} ifr - The iframe to check against\r\n   * @return {boolean}\r\n   * @access protected\r\n   */\r\n  compareNodeIframe(node, prevNode, ifr) {\r\n    const compCurr = node.compareDocumentPosition(ifr),\r\n      prev = Node.DOCUMENT_POSITION_PRECEDING;\r\n    if (compCurr & prev) {\r\n      if (prevNode !== null) {\r\n        const compPrev = prevNode.compareDocumentPosition(ifr),\r\n          after = Node.DOCUMENT_POSITION_FOLLOWING;\r\n        if (compPrev & after) {\r\n          return true;\r\n        }\r\n      } else {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @typedef {DOMIterator~getIteratorNodeReturn}\r\n   * @type {object.<string>}\r\n   * @property {HTMLElement} prevNode - The previous node or null if there is\r\n   * no\r\n   * @property {HTMLElement} node - The current node\r\n   */\r\n  /**\r\n   * Returns the previous and current node of the specified iterator\r\n   * @param {NodeIterator} itr - The iterator\r\n   * @return {DOMIterator~getIteratorNodeReturn}\r\n   * @access protected\r\n   */\r\n  getIteratorNode(itr) {\r\n    const prevNode = itr.previousNode();\r\n    let node;\r\n    if (prevNode === null) {\r\n      node = itr.nextNode();\r\n    } else {\r\n      node = itr.nextNode() && itr.nextNode();\r\n    }\r\n    return {\r\n      prevNode,\r\n      node\r\n    };\r\n  }\r\n\r\n  /**\r\n   * An array containing objects. The object key \"val\" contains an iframe\r\n   * DOM element. The object key \"handled\" contains a boolean indicating if\r\n   * the iframe was handled already.\r\n   * It wouldn't be enough to save all open or all already handled iframes.\r\n   * The information of open iframes is necessary because they may occur after\r\n   * all other text nodes (and compareNodeIframe would never be true). The\r\n   * information of already handled iframes is necessary as otherwise they may\r\n   * be handled multiple times\r\n   * @typedef DOMIterator~checkIframeFilterIfr\r\n   * @type {object[]}\r\n   */\r\n  /**\r\n   * Checks if an iframe wasn't handled already and if so, calls\r\n   * {@link DOMIterator#compareNodeIframe} to check if it should be handled.\r\n   * Information wheter an iframe was or wasn't handled is given within the\r\n   * <code>ifr</code> dictionary\r\n   * @param {HTMLElement} node - The node that should occur after the iframe\r\n   * @param {HTMLElement} prevNode - The node that should occur before the\r\n   * iframe\r\n   * @param {HTMLElement} currIfr - The iframe to check\r\n   * @param {DOMIterator~checkIframeFilterIfr} ifr - The iframe dictionary.\r\n   * Will be manipulated (by reference)\r\n   * @return {boolean} Returns true when it should be handled, otherwise false\r\n   * @access protected\r\n   */\r\n  checkIframeFilter(node, prevNode, currIfr, ifr) {\r\n    let key = false, // false === doesn't exist\r\n      handled = false;\r\n    ifr.forEach((ifrDict, i) => {\r\n      if (ifrDict.val === currIfr) {\r\n        key = i;\r\n        handled = ifrDict.handled;\r\n      }\r\n    });\r\n    if (this.compareNodeIframe(node, prevNode, currIfr)) {\r\n      if (key === false && !handled) {\r\n        ifr.push({\r\n          val: currIfr,\r\n          handled: true\r\n        });\r\n      } else if (key !== false && !handled) {\r\n        ifr[key].handled = true;\r\n      }\r\n      return true;\r\n    }\r\n    if (key === false) {\r\n      ifr.push({\r\n        val: currIfr,\r\n        handled: false\r\n      });\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Creates an iterator on all open iframes in the specified array and calls\r\n   * the end callback when finished\r\n   * @param {DOMIterator~checkIframeFilterIfr} ifr\r\n   * @param {DOMIterator~whatToShow} whatToShow\r\n   * @param  {DOMIterator~forEachNodeCallback} eCb - Each callback\r\n   * @param {DOMIterator~filterCb} fCb\r\n   * @access protected\r\n   */\r\n  handleOpenIframes(ifr, whatToShow, eCb, fCb) {\r\n    ifr.forEach(ifrDict => {\r\n      if (!ifrDict.handled) {\r\n        this.getIframeContents(ifrDict.val, con => {\r\n          this.createInstanceOnIframe(con).forEachNode(\r\n            whatToShow, eCb, fCb\r\n          );\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Iterates through all nodes in the specified context and handles iframe\r\n   * nodes at the correct position\r\n   * @param {DOMIterator~whatToShow} whatToShow\r\n   * @param {HTMLElement} ctx - The context\r\n   * @param  {DOMIterator~forEachNodeCallback} eachCb - Each callback\r\n   * @param {DOMIterator~filterCb} filterCb - Filter callback\r\n   * @param {DOMIterator~forEachNodeEndCallback} doneCb - End callback\r\n   * @access protected\r\n   */\r\n  iterateThroughNodes(whatToShow, ctx, eachCb, filterCb, doneCb) {\r\n    const itr = this.createIterator(ctx, whatToShow, filterCb);\r\n    let ifr = [],\r\n      elements = [],\r\n      node, prevNode, retrieveNodes = () => {\r\n        ({\r\n          prevNode,\r\n          node\r\n        } = this.getIteratorNode(itr));\r\n        return node;\r\n      };\r\n    while (retrieveNodes()) {\r\n      if (this.iframes) {\r\n        this.forEachIframe(ctx, currIfr => {\r\n          // note that ifr will be manipulated here\r\n          return this.checkIframeFilter(node, prevNode, currIfr, ifr);\r\n        }, con => {\r\n          this.createInstanceOnIframe(con).forEachNode(\r\n            whatToShow, ifrNode => elements.push(ifrNode), filterCb\r\n          );\r\n        });\r\n      }\r\n      // it's faster to call the each callback in an array loop\r\n      // than in this while loop\r\n      elements.push(node);\r\n    }\r\n    elements.forEach(node => {\r\n      eachCb(node);\r\n    });\r\n    if (this.iframes) {\r\n      this.handleOpenIframes(ifr, whatToShow, eachCb, filterCb);\r\n    }\r\n    doneCb();\r\n  }\r\n\r\n  /**\r\n   * Callback for each node\r\n   * @callback DOMIterator~forEachNodeCallback\r\n   * @param {HTMLElement} node - The DOM text node element\r\n   */\r\n  /**\r\n   * Callback if all contexts were handled\r\n   * @callback DOMIterator~forEachNodeEndCallback\r\n   */\r\n  /**\r\n   * Iterates over all contexts and initializes\r\n   * {@link DOMIterator#iterateThroughNodes iterateThroughNodes} on them\r\n   * @param {DOMIterator~whatToShow} whatToShow\r\n   * @param  {DOMIterator~forEachNodeCallback} each - Each callback\r\n   * @param {DOMIterator~filterCb} filter - Filter callback\r\n   * @param {DOMIterator~forEachNodeEndCallback} done - End callback\r\n   * @access public\r\n   */\r\n  forEachNode(whatToShow, each, filter, done = () => {}) {\r\n    const contexts = this.getContexts();\r\n    let open = contexts.length;\r\n    if (!open) {\r\n      done();\r\n    }\r\n    contexts.forEach(ctx => {\r\n      const ready = () => {\r\n        this.iterateThroughNodes(whatToShow, ctx, each, filter, () => {\r\n          if (--open <= 0) { // call end all contexts were handled\r\n            done();\r\n          }\r\n        });\r\n      };\r\n      // wait for iframes to avoid recursive calls, otherwise this would\r\n      // perhaps reach the recursive function call limit with many nodes\r\n      if (this.iframes) {\r\n        this.waitForIframes(ctx, ready);\r\n      } else {\r\n        ready();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Callback to filter nodes. Can return e.g. NodeFilter.FILTER_ACCEPT or\r\n   * NodeFilter.FILTER_REJECT\r\n   * @see {@link http://tinyurl.com/zdczmm2}\r\n   * @callback DOMIterator~filterCb\r\n   * @param {HTMLElement} node - The node to filter\r\n   */\r\n  /**\r\n   * @typedef DOMIterator~whatToShow\r\n   * @see {@link http://tinyurl.com/zfqqkx2}\r\n   * @type {number}\r\n   */\r\n}\r\n", "import DOMIterator from './domiterator';\r\n\r\n/**\r\n * Marks search terms in DOM elements\r\n * @example\r\n * new Mark(document.querySelector(\".context\")).mark(\"lorem ipsum\");\r\n * @example\r\n * new Mark(document.querySelector(\".context\")).markRegExp(/lorem/gmi);\r\n */\r\nexport default class Mark { // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n   * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM\r\n   * element, an array of DOM elements, a NodeList or a selector\r\n   */\r\n  constructor(ctx) {\r\n    /**\r\n     * The context of the instance. Either a DOM element, an array of DOM\r\n     * elements, a NodeList or a selector\r\n     * @type {HTMLElement|HTMLElement[]|NodeList|string}\r\n     * @access protected\r\n     */\r\n    this.ctx = ctx;\r\n    /**\r\n     * Specifies if the current browser is a IE (necessary for the node\r\n     * normalization bug workaround). See {@link Mark#unwrapMatches}\r\n     * @type {boolean}\r\n     * @access protected\r\n     */\r\n    this.ie = false;\r\n    const ua = window.navigator.userAgent;\r\n    if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) {\r\n      this.ie = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Options defined by the user. They will be initialized from one of the\r\n   * public methods. See {@link Mark#mark}, {@link Mark#markRegExp},\r\n   * {@link Mark#markRanges} and {@link Mark#unmark} for option properties.\r\n   * @type {object}\r\n   * @param {object} [val] - An object that will be merged with defaults\r\n   * @access protected\r\n   */\r\n  set opt(val) {\r\n    this._opt = Object.assign({}, {\r\n      'element': '',\r\n      'className': '',\r\n      'exclude': [],\r\n      'iframes': false,\r\n      'iframesTimeout': 5000,\r\n      'separateWordSearch': true,\r\n      'diacritics': true,\r\n      'synonyms': {},\r\n      'accuracy': 'partially',\r\n      'acrossElements': false,\r\n      'caseSensitive': false,\r\n      'ignoreJoiners': false,\r\n      'ignoreGroups': 0,\r\n      'ignorePunctuation': [],\r\n      'wildcards': 'disabled',\r\n      'each': () => {},\r\n      'noMatch': () => {},\r\n      'filter': () => true,\r\n      'done': () => {},\r\n      'debug': false,\r\n      'log': window.console\r\n    }, val);\r\n  }\r\n\r\n  get opt() {\r\n    return this._opt;\r\n  }\r\n\r\n  /**\r\n   * An instance of DOMIterator\r\n   * @type {DOMIterator}\r\n   * @access protected\r\n   */\r\n  get iterator() {\r\n    // always return new instance in case there were option changes\r\n    return new DOMIterator(\r\n      this.ctx,\r\n      this.opt.iframes,\r\n      this.opt.exclude,\r\n      this.opt.iframesTimeout\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Logs a message if log is enabled\r\n   * @param {string} msg - The message to log\r\n   * @param {string} [level=\"debug\"] - The log level, e.g. <code>warn</code>\r\n   * <code>error</code>, <code>debug</code>\r\n   * @access protected\r\n   */\r\n  log(msg, level = 'debug') {\r\n    const log = this.opt.log;\r\n    if (!this.opt.debug) {\r\n      return;\r\n    }\r\n    if (typeof log === 'object' && typeof log[level] === 'function') {\r\n      log[level](`mark.js: ${msg}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Escapes a string for usage within a regular expression\r\n   * @param {string} str - The string to escape\r\n   * @return {string}\r\n   * @access protected\r\n   */\r\n  escapeStr(str) {\r\n    // eslint-disable-next-line no-useless-escape\r\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\r\n  }\r\n\r\n  /**\r\n   * Creates a regular expression string to match the specified search\r\n   * term including synonyms, diacritics and accuracy if defined\r\n   * @param  {string} str - The search term to be used\r\n   * @return {string}\r\n   * @access protected\r\n   */\r\n  createRegExp(str) {\r\n    if (this.opt.wildcards !== 'disabled') {\r\n      str = this.setupWildcardsRegExp(str);\r\n    }\r\n    str = this.escapeStr(str);\r\n    if (Object.keys(this.opt.synonyms).length) {\r\n      str = this.createSynonymsRegExp(str);\r\n    }\r\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\r\n      str = this.setupIgnoreJoinersRegExp(str);\r\n    }\r\n    if (this.opt.diacritics) {\r\n      str = this.createDiacriticsRegExp(str);\r\n    }\r\n    str = this.createMergedBlanksRegExp(str);\r\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\r\n      str = this.createJoinersRegExp(str);\r\n    }\r\n    if (this.opt.wildcards !== 'disabled') {\r\n      str = this.createWildcardsRegExp(str);\r\n    }\r\n    str = this.createAccuracyRegExp(str);\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Creates a regular expression string to match the defined synonyms\r\n   * @param  {string} str - The search term to be used\r\n   * @return {string}\r\n   * @access protected\r\n   */\r\n  createSynonymsRegExp(str) {\r\n    const syn = this.opt.synonyms,\r\n      sens = this.opt.caseSensitive ? '' : 'i',\r\n      // add replacement character placeholder before and after the\r\n      // synonym group\r\n      joinerPlaceholder = this.opt.ignoreJoiners ||\r\n                this.opt.ignorePunctuation.length ? '\\u0000' : '';\r\n    for (let index in syn) {\r\n      if (syn.hasOwnProperty(index)) {\r\n        const value = syn[index],\r\n          k1 = this.opt.wildcards !== 'disabled' ?\r\n            this.setupWildcardsRegExp(index) :\r\n            this.escapeStr(index),\r\n          k2 = this.opt.wildcards !== 'disabled' ?\r\n            this.setupWildcardsRegExp(value) :\r\n            this.escapeStr(value);\r\n        if (k1 !== '' && k2 !== '') {\r\n          str = str.replace(\r\n            new RegExp(\r\n              `(${this.escapeStr(k1)}|${this.escapeStr(k2)})`,\r\n              `gm${sens}`\r\n            ),\r\n            joinerPlaceholder +\r\n            `(${this.processSynomyms(k1)}|` +\r\n            `${this.processSynomyms(k2)})` +\r\n            joinerPlaceholder\r\n          );\r\n        }\r\n      }\r\n    }\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Setup synonyms to work with ignoreJoiners and or ignorePunctuation\r\n   * @param {string} str - synonym key or value to process\r\n   * @return {string} - processed synonym string\r\n   */\r\n  processSynomyms(str) {\r\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\r\n      str = this.setupIgnoreJoinersRegExp(str);\r\n    }\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Sets up the regular expression string to allow later insertion of\r\n   * wildcard regular expression matches\r\n   * @param  {string} str - The search term to be used\r\n   * @return {string}\r\n   * @access protected\r\n   */\r\n  setupWildcardsRegExp(str) {\r\n    // replace single character wildcard with unicode 0001\r\n    str = str.replace(/(?:\\\\)*\\?/g, val => {\r\n      return val.charAt(0) === '\\\\' ? '?' : '\\u0001';\r\n    });\r\n    // replace multiple character wildcard with unicode 0002\r\n    return str.replace(/(?:\\\\)*\\*/g, val => {\r\n      return val.charAt(0) === '\\\\' ? '*' : '\\u0002';\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sets up the regular expression string to allow later insertion of\r\n   * wildcard regular expression matches\r\n   * @param  {string} str - The search term to be used\r\n   * @return {string}\r\n   * @access protected\r\n   */\r\n  createWildcardsRegExp(str) {\r\n    // default to \"enable\" (i.e. to not include spaces)\r\n    // \"withSpaces\" uses `[\\\\S\\\\s]` instead of `.` because the latter\r\n    // does not match new line characters\r\n    let spaces = this.opt.wildcards === 'withSpaces';\r\n    return str\r\n    // replace unicode 0001 with a RegExp class to match any single\r\n    // character, or any single non-whitespace character depending\r\n    // on the setting\r\n      .replace(/\\u0001/g, spaces ? '[\\\\S\\\\s]?' : '\\\\S?')\r\n    // replace unicode 0002 with a RegExp class to match zero or\r\n    // more characters, or zero or more non-whitespace characters\r\n    // depending on the setting\r\n      .replace(/\\u0002/g, spaces ? '[\\\\S\\\\s]*?' : '\\\\S*');\r\n  }\r\n\r\n  /**\r\n   * Sets up the regular expression string to allow later insertion of\r\n   * designated characters (soft hyphens & zero width characters)\r\n   * @param  {string} str - The search term to be used\r\n   * @return {string}\r\n   * @access protected\r\n   */\r\n  setupIgnoreJoinersRegExp(str) {\r\n    // adding a \"null\" unicode character as it will not be modified by the\r\n    // other \"create\" regular expression functions\r\n    return str.replace(/[^(|)\\\\]/g, (val, indx, original) => {\r\n      // don't add a null after an opening \"(\", around a \"|\" or before\r\n      // a closing \"(\", or between an escapement (e.g. \\+)\r\n      let nextChar = original.charAt(indx + 1);\r\n      if (/[(|)\\\\]/.test(nextChar) || nextChar === '') {\r\n        return val;\r\n      } else {\r\n        return val + '\\u0000';\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a regular expression string to allow ignoring of designated\r\n   * characters (soft hyphens, zero width characters & punctuation) based on\r\n   * the specified option values of <code>ignorePunctuation</code> and\r\n   * <code>ignoreJoiners</code>\r\n   * @param  {string} str - The search term to be used\r\n   * @return {string}\r\n   * @access protected\r\n   */\r\n  createJoinersRegExp(str) {\r\n    let joiner = [];\r\n    const ignorePunctuation = this.opt.ignorePunctuation;\r\n    if (Array.isArray(ignorePunctuation) && ignorePunctuation.length) {\r\n      joiner.push(this.escapeStr(ignorePunctuation.join('')));\r\n    }\r\n    if (this.opt.ignoreJoiners) {\r\n      // u+00ad = soft hyphen\r\n      // u+200b = zero-width space\r\n      // u+200c = zero-width non-joiner\r\n      // u+200d = zero-width joiner\r\n      joiner.push('\\\\u00ad\\\\u200b\\\\u200c\\\\u200d');\r\n    }\r\n    return joiner.length ?\r\n      str.split(/\\u0000+/).join(`[${joiner.join('')}]*`) :\r\n      str;\r\n  }\r\n\r\n  /**\r\n   * Creates a regular expression string to match diacritics\r\n   * @param  {string} str - The search term to be used\r\n   * @return {string}\r\n   * @access protected\r\n   */\r\n  createDiacriticsRegExp(str) {\r\n    const sens = this.opt.caseSensitive ? '' : 'i',\r\n      dct = this.opt.caseSensitive ? [\r\n        'aàáảãạăằắẳẵặâầấẩẫậäåāą', 'AÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ',\r\n        'cçćč', 'CÇĆČ', 'dđď', 'DĐĎ',\r\n        'eèéẻẽẹêềếểễệëěēę', 'EÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ',\r\n        'iìíỉĩịîïī', 'IÌÍỈĨỊÎÏĪ', 'lł', 'LŁ', 'nñňń',\r\n        'NÑŇŃ', 'oòóỏõọôồốổỗộơởỡớờợöøō', 'OÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ',\r\n        'rř', 'RŘ', 'sšśșş', 'SŠŚȘŞ',\r\n        'tťțţ', 'TŤȚŢ', 'uùúủũụưừứửữựûüůū', 'UÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ',\r\n        'yýỳỷỹỵÿ', 'YÝỲỶỸỴŸ', 'zžżź', 'ZŽŻŹ'\r\n      ] : [\r\n        'aàáảãạăằắẳẵặâầấẩẫậäåāąAÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ', 'cçćčCÇĆČ',\r\n        'dđďDĐĎ', 'eèéẻẽẹêềếểễệëěēęEÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ',\r\n        'iìíỉĩịîïīIÌÍỈĨỊÎÏĪ', 'lłLŁ', 'nñňńNÑŇŃ',\r\n        'oòóỏõọôồốổỗộơởỡớờợöøōOÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ', 'rřRŘ',\r\n        'sšśșşSŠŚȘŞ', 'tťțţTŤȚŢ',\r\n        'uùúủũụưừứửữựûüůūUÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ', 'yýỳỷỹỵÿYÝỲỶỸỴŸ', 'zžżźZŽŻŹ'\r\n      ];\r\n    let handled = [];\r\n    str.split('').forEach(ch => {\r\n      dct.every(dct => {\r\n        // Check if the character is inside a diacritics list\r\n        if (dct.indexOf(ch) !== -1) {\r\n          // Check if the related diacritics list was not\r\n          // handled yet\r\n          if (handled.indexOf(dct) > -1) {\r\n            return false;\r\n          }\r\n          // Make sure that the character OR any other\r\n          // character in the diacritics list will be matched\r\n          str = str.replace(\r\n            new RegExp(`[${dct}]`, `gm${sens}`), `[${dct}]`\r\n          );\r\n          handled.push(dct);\r\n        }\r\n        return true;\r\n      });\r\n    });\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Creates a regular expression string that merges whitespace characters\r\n   * including subsequent ones into a single pattern, one or multiple\r\n   * whitespaces\r\n   * @param  {string} str - The search term to be used\r\n   * @return {string}\r\n   * @access protected\r\n   */\r\n  createMergedBlanksRegExp(str) {\r\n    return str.replace(/[\\s]+/gmi, '[\\\\s]+');\r\n  }\r\n\r\n  /**\r\n   * Creates a regular expression string to match the specified string with\r\n   * the defined accuracy. As in the regular expression of \"exactly\" can be\r\n   * a group containing a blank at the beginning, all regular expressions will\r\n   * be created with two groups. The first group can be ignored (may contain\r\n   * the said blank), the second contains the actual match\r\n   * @param  {string} str - The searm term to be used\r\n   * @return {str}\r\n   * @access protected\r\n   */\r\n  createAccuracyRegExp(str) {\r\n    const chars = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~¡¿';\r\n    let acc = this.opt.accuracy,\r\n      val = typeof acc === 'string' ? acc : acc.value,\r\n      ls = typeof acc === 'string' ? [] : acc.limiters,\r\n      lsJoin = '';\r\n    ls.forEach(limiter => {\r\n      lsJoin += `|${this.escapeStr(limiter)}`;\r\n    });\r\n    switch (val) {\r\n    case 'partially':\r\n    default:\r\n      return `()(${str})`;\r\n    case 'complementary':\r\n      lsJoin = '\\\\s' + (lsJoin ? lsJoin : this.escapeStr(chars));\r\n      return `()([^${lsJoin}]*${str}[^${lsJoin}]*)`;\r\n    case 'exactly':\r\n      return `(^|\\\\s${lsJoin})(${str})(?=$|\\\\s${lsJoin})`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @typedef Mark~separatedKeywords\r\n   * @type {object.<string>}\r\n   * @property {array.<string>} keywords - The list of keywords\r\n   * @property {number} length - The length\r\n   */\r\n  /**\r\n   * Returns a list of keywords dependent on whether separate word search\r\n   * was defined. Also it filters empty keywords\r\n   * @param {array} sv - The array of keywords\r\n   * @return {Mark~separatedKeywords}\r\n   * @access protected\r\n   */\r\n  getSeparatedKeywords(sv) {\r\n    let stack = [];\r\n    sv.forEach(kw => {\r\n      if (!this.opt.separateWordSearch) {\r\n        if (kw.trim() && stack.indexOf(kw) === -1) {\r\n          stack.push(kw);\r\n        }\r\n      } else {\r\n        kw.split(' ').forEach(kwSplitted => {\r\n          if (kwSplitted.trim() && stack.indexOf(kwSplitted) === -1) {\r\n            stack.push(kwSplitted);\r\n          }\r\n        });\r\n      }\r\n    });\r\n    return {\r\n      // sort because of https://git.io/v6USg\r\n      'keywords': stack.sort((a, b) => {\r\n        return b.length - a.length;\r\n      }),\r\n      'length': stack.length\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if a value is a number\r\n   * @param {number|string} value - the value to check;\r\n   * numeric strings allowed\r\n   * @return {boolean}\r\n   * @access protected\r\n   */\r\n  isNumeric(value) {\r\n    // http://stackoverflow.com/a/16655847/145346\r\n    // eslint-disable-next-line eqeqeq\r\n    return Number(parseFloat(value)) == value;\r\n  }\r\n\r\n  /**\r\n   * @typedef Mark~rangeObject\r\n   * @type {object}\r\n   * @property {number} start - The start position within the composite value\r\n   * @property {number} length - The length of the string to mark within the\r\n   * composite value.\r\n   */\r\n  /**\r\n   * @typedef Mark~setOfRanges\r\n   * @type {object[]}\r\n   * @property {Mark~rangeObject}\r\n   */\r\n  /**\r\n   * Returns a processed list of integer offset indexes that do not overlap\r\n   * each other, and remove any string values or additional elements\r\n   * @param {Mark~setOfRanges} array - unprocessed raw array\r\n   * @return {Mark~setOfRanges} - processed array with any invalid entries\r\n   * removed\r\n   * @throws Will throw an error if an array of objects is not passed\r\n   * @access protected\r\n   */\r\n  checkRanges(array) {\r\n    // start and length indexes are included in an array of objects\r\n    // [{start: 0, length: 1}, {start: 4, length: 5}]\r\n    // quick validity check of the first entry only\r\n    if (\r\n      !Array.isArray(array) ||\r\n      Object.prototype.toString.call( array[0] ) !== '[object Object]'\r\n    ) {\r\n      this.log('markRanges() will only accept an array of objects');\r\n      this.opt.noMatch(array);\r\n      return [];\r\n    }\r\n    const stack = [];\r\n    let last = 0;\r\n    array\r\n    // acending sort to ensure there is no overlap in start & end\r\n    // offsets\r\n      .sort((a, b) => {\r\n        return a.start - b.start;\r\n      })\r\n      .forEach(item => {\r\n        let {start, end, valid} = this.callNoMatchOnInvalidRanges(item, last);\r\n        if (valid) {\r\n          // preserve item in case there are extra key:values within\r\n          item.start = start;\r\n          item.length = end - start;\r\n          stack.push(item);\r\n          last = end;\r\n        }\r\n      });\r\n    return stack;\r\n  }\r\n\r\n  /**\r\n   * @typedef Mark~validObject\r\n   * @type {object}\r\n   * @property {number} start - The start position within the composite value\r\n   * @property {number} end - The calculated end position within the composite\r\n   * value.\r\n   * @property {boolean} valid - boolean value indicating that the start and\r\n   * calculated end range is valid\r\n   */\r\n  /**\r\n    * Initial validation of ranges for markRanges. Preliminary checks are done\r\n    * to ensure the start and length values exist and are not zero or non-\r\n    * numeric\r\n    * @param {Mark~rangeObject} range - the current range object\r\n    * @param {number} last - last index of range\r\n    * @return {Mark~validObject}\r\n    * @access protected\r\n    */\r\n  callNoMatchOnInvalidRanges(range, last) {\r\n    let start, end,\r\n      valid = false;\r\n    if (range && typeof range.start !== 'undefined') {\r\n      start = parseInt(range.start, 10);\r\n      end = start + parseInt(range.length, 10);\r\n      // ignore overlapping values & non-numeric entries\r\n      if (\r\n        this.isNumeric(range.start) &&\r\n        this.isNumeric(range.length) &&\r\n        end - last > 0 &&\r\n        end - start > 0\r\n      ) {\r\n        valid = true;\r\n      } else {\r\n        this.log(\r\n          'Ignoring invalid or overlapping range: ' +\r\n                    `${JSON.stringify(range)}`\r\n        );\r\n        this.opt.noMatch(range);\r\n      }\r\n    } else {\r\n      this.log(`Ignoring invalid range: ${JSON.stringify(range)}`);\r\n      this.opt.noMatch(range);\r\n    }\r\n    return {\r\n      start: start,\r\n      end: end,\r\n      valid: valid\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check valid range for markRanges. Check ranges with access to the context\r\n   * string. Range values are double checked, lengths that extend the mark\r\n   * beyond the string length are limitied and ranges containing only\r\n   * whitespace are ignored\r\n   * @param {Mark~rangeObject} range - the current range object\r\n   * @param {number} originalLength - original length of the context string\r\n   * @param {string} string - current content string\r\n   * @return {Mark~validObject}\r\n   * @access protected\r\n   */\r\n  checkWhitespaceRanges(range, originalLength, string) {\r\n    let end,\r\n      valid = true,\r\n      // the max value changes after the DOM is manipulated\r\n      max = string.length,\r\n      // adjust offset to account for wrapped text node\r\n      offset = originalLength - max,\r\n      start = parseInt(range.start, 10) - offset;\r\n    // make sure to stop at max\r\n    start = start > max ? max : start;\r\n    end = start + parseInt(range.length, 10);\r\n    if (end > max) {\r\n      end = max;\r\n      this.log(`End range automatically set to the max value of ${max}`);\r\n    }\r\n    if (start < 0 || end - start < 0 || start > max || end > max) {\r\n      valid = false;\r\n      this.log(`Invalid range: ${JSON.stringify(range)}`);\r\n      this.opt.noMatch(range);\r\n    } else if (string.substring(start, end).replace(/\\s+/g, '') === '') {\r\n      valid = false;\r\n      // whitespace only; even if wrapped it is not visible\r\n      this.log('Skipping whitespace only range: ' +JSON.stringify(range));\r\n      this.opt.noMatch(range);\r\n    }\r\n    return {\r\n      start: start,\r\n      end: end,\r\n      valid: valid\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @typedef Mark~getTextNodesDict\r\n   * @type {object.<string>}\r\n   * @property {string} value - The composite value of all text nodes\r\n   * @property {object[]} nodes - An array of objects\r\n   * @property {number} nodes.start - The start position within the composite\r\n   * value\r\n   * @property {number} nodes.end - The end position within the composite\r\n   * value\r\n   * @property {HTMLElement} nodes.node - The DOM text node element\r\n   */\r\n  /**\r\n   * Callback\r\n   * @callback Mark~getTextNodesCallback\r\n   * @param {Mark~getTextNodesDict}\r\n   */\r\n  /**\r\n   * Calls the callback with an object containing all text nodes (including\r\n   * iframe text nodes) with start and end positions and the composite value\r\n   * of them (string)\r\n   * @param {Mark~getTextNodesCallback} cb - Callback\r\n   * @access protected\r\n   */\r\n  getTextNodes(cb) {\r\n    let val = '',\r\n      nodes = [];\r\n    this.iterator.forEachNode(NodeFilter.SHOW_TEXT, node => {\r\n      nodes.push({\r\n        start: val.length,\r\n        end: (val += node.textContent).length,\r\n        node\r\n      });\r\n    }, node => {\r\n      if (this.matchesExclude(node.parentNode)) {\r\n        return NodeFilter.FILTER_REJECT;\r\n      } else {\r\n        return NodeFilter.FILTER_ACCEPT;\r\n      }\r\n    }, () => {\r\n      cb({\r\n        value: val,\r\n        nodes: nodes\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Checks if an element matches any of the specified exclude selectors. Also\r\n   * it checks for elements in which no marks should be performed (e.g.\r\n   * script and style tags) and optionally already marked elements\r\n   * @param  {HTMLElement} el - The element to check\r\n   * @return {boolean}\r\n   * @access protected\r\n   */\r\n  matchesExclude(el) {\r\n    return DOMIterator.matches(el, this.opt.exclude.concat([\r\n      // ignores the elements itself, not their childrens (selector *)\r\n      'script', 'style', 'title', 'head', 'html'\r\n    ]));\r\n  }\r\n\r\n  /**\r\n   * Wraps the instance element and class around matches that fit the start\r\n   * and end positions within the node\r\n   * @param  {HTMLElement} node - The DOM text node\r\n   * @param  {number} start - The position where to start wrapping\r\n   * @param  {number} end - The position where to end wrapping\r\n   * @return {HTMLElement} Returns the splitted text node that will appear\r\n   * after the wrapped text node\r\n   * @access protected\r\n   */\r\n  wrapRangeInTextNode(node, start, end) {\r\n    const hEl = !this.opt.element ? 'mark' : this.opt.element,\r\n      startNode = node.splitText(start),\r\n      ret = startNode.splitText(end - start);\r\n    let repl = document.createElement(hEl);\r\n    repl.setAttribute('data-markjs', 'true');\r\n    if (this.opt.className) {\r\n      repl.setAttribute('class', this.opt.className);\r\n    }\r\n    repl.textContent = startNode.textContent;\r\n    startNode.parentNode.replaceChild(repl, startNode);\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * @typedef Mark~wrapRangeInMappedTextNodeDict\r\n   * @type {object.<string>}\r\n   * @property {string} value - The composite value of all text nodes\r\n   * @property {object[]} nodes - An array of objects\r\n   * @property {number} nodes.start - The start position within the composite\r\n   * value\r\n   * @property {number} nodes.end - The end position within the composite\r\n   * value\r\n   * @property {HTMLElement} nodes.node - The DOM text node element\r\n   */\r\n  /**\r\n   * Each callback\r\n   * @callback Mark~wrapMatchesEachCallback\r\n   * @param {HTMLElement} node - The wrapped DOM element\r\n   * @param {number} lastIndex - The last matching position within the\r\n   * composite value of text nodes\r\n   */\r\n  /**\r\n   * Filter callback\r\n   * @callback Mark~wrapMatchesFilterCallback\r\n   * @param {HTMLElement} node - The matching text node DOM element\r\n   */\r\n  /**\r\n   * Determines matches by start and end positions using the text node\r\n   * dictionary even across text nodes and calls\r\n   * {@link Mark#wrapRangeInTextNode} to wrap them\r\n   * @param  {Mark~wrapRangeInMappedTextNodeDict} dict - The dictionary\r\n   * @param  {number} start - The start position of the match\r\n   * @param  {number} end - The end position of the match\r\n   * @param  {Mark~wrapMatchesFilterCallback} filterCb - Filter callback\r\n   * @param  {Mark~wrapMatchesEachCallback} eachCb - Each callback\r\n   * @access protected\r\n   */\r\n  wrapRangeInMappedTextNode(dict, start, end, filterCb, eachCb) {\r\n    // iterate over all text nodes to find the one matching the positions\r\n    dict.nodes.every((n, i) => {\r\n      const sibl = dict.nodes[i + 1];\r\n      if (typeof sibl === 'undefined' || sibl.start > start) {\r\n        if (!filterCb(n.node)) {\r\n          return false;\r\n        }\r\n        // map range from dict.value to text node\r\n        const s = start - n.start,\r\n          e = (end > n.end ? n.end : end) - n.start,\r\n          startStr = dict.value.substr(0, n.start),\r\n          endStr = dict.value.substr(e + n.start);\r\n        n.node = this.wrapRangeInTextNode(n.node, s, e);\r\n        // recalculate positions to also find subsequent matches in the\r\n        // same text node. Necessary as the text node in dict now only\r\n        // contains the splitted part after the wrapped one\r\n        dict.value = startStr + endStr;\r\n        dict.nodes.forEach((k, j) => {\r\n          if (j >= i) {\r\n            if (dict.nodes[j].start > 0 && j !== i) {\r\n              dict.nodes[j].start -= e;\r\n            }\r\n            dict.nodes[j].end -= e;\r\n          }\r\n        });\r\n        end -= e;\r\n        eachCb(n.node.previousSibling, n.start);\r\n        if (end > n.end) {\r\n          start = n.end;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Filter callback before each wrapping\r\n   * @callback Mark~wrapMatchesFilterCallback\r\n   * @param {string} match - The matching string\r\n   * @param {HTMLElement} node - The text node where the match occurs\r\n   */\r\n  /**\r\n   * Callback for each wrapped element\r\n   * @callback Mark~wrapMatchesEachCallback\r\n   * @param {HTMLElement} element - The marked DOM element\r\n   */\r\n  /**\r\n   * Callback on end\r\n   * @callback Mark~wrapMatchesEndCallback\r\n   */\r\n  /**\r\n   * Wraps the instance element and class around matches within single HTML\r\n   * elements in all contexts\r\n   * @param {RegExp} regex - The regular expression to be searched for\r\n   * @param {number} ignoreGroups - A number indicating the amount of RegExp\r\n   * matching groups to ignore\r\n   * @param {Mark~wrapMatchesFilterCallback} filterCb\r\n   * @param {Mark~wrapMatchesEachCallback} eachCb\r\n   * @param {Mark~wrapMatchesEndCallback} endCb\r\n   * @access protected\r\n   */\r\n  wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {\r\n    const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\r\n    this.getTextNodes(dict => {\r\n      dict.nodes.forEach(node => {\r\n        node = node.node;\r\n        let match;\r\n        while (\r\n          (match = regex.exec(node.textContent)) !== null &&\r\n          match[matchIdx] !== ''\r\n        ) {\r\n          if (!filterCb(match[matchIdx], node)) {\r\n            continue;\r\n          }\r\n          let pos = match.index;\r\n          if (matchIdx !== 0) {\r\n            for (let i = 1; i < matchIdx; i++) {\r\n              pos += match[i].length;\r\n            }\r\n          }\r\n          node = this.wrapRangeInTextNode(\r\n            node,\r\n            pos,\r\n            pos + match[matchIdx].length\r\n          );\r\n          eachCb(node.previousSibling);\r\n          // reset index of last match as the node changed and the\r\n          // index isn't valid anymore http://tinyurl.com/htsudjd\r\n          regex.lastIndex = 0;\r\n        }\r\n      });\r\n      endCb();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Callback for each wrapped element\r\n   * @callback Mark~wrapMatchesAcrossElementsEachCallback\r\n   * @param {HTMLElement} element - The marked DOM element\r\n   */\r\n  /**\r\n   * Filter callback before each wrapping\r\n   * @callback Mark~wrapMatchesAcrossElementsFilterCallback\r\n   * @param {string} match - The matching string\r\n   * @param {HTMLElement} node - The text node where the match occurs\r\n   */\r\n  /**\r\n   * Callback on end\r\n   * @callback Mark~wrapMatchesAcrossElementsEndCallback\r\n   */\r\n  /**\r\n   * Wraps the instance element and class around matches across all HTML\r\n   * elements in all contexts\r\n   * @param {RegExp} regex - The regular expression to be searched for\r\n   * @param {number} ignoreGroups - A number indicating the amount of RegExp\r\n   * matching groups to ignore\r\n   * @param {Mark~wrapMatchesAcrossElementsFilterCallback} filterCb\r\n   * @param {Mark~wrapMatchesAcrossElementsEachCallback} eachCb\r\n   * @param {Mark~wrapMatchesAcrossElementsEndCallback} endCb\r\n   * @access protected\r\n   */\r\n  wrapMatchesAcrossElements(regex, ignoreGroups, filterCb, eachCb, endCb) {\r\n    const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\r\n    this.getTextNodes(dict => {\r\n      let match;\r\n      while (\r\n        (match = regex.exec(dict.value)) !== null &&\r\n        match[matchIdx] !== ''\r\n      ) {\r\n        // calculate range inside dict.value\r\n        let start = match.index;\r\n        if (matchIdx !== 0) {\r\n          for (let i = 1; i < matchIdx; i++) {\r\n            start += match[i].length;\r\n          }\r\n        }\r\n        const end = start + match[matchIdx].length;\r\n        // note that dict will be updated automatically, as it'll change\r\n        // in the wrapping process, due to the fact that text\r\n        // nodes will be splitted\r\n        this.wrapRangeInMappedTextNode(dict, start, end, node => {\r\n          return filterCb(match[matchIdx], node);\r\n        }, (node, lastIndex) => {\r\n          regex.lastIndex = lastIndex;\r\n          eachCb(node);\r\n        });\r\n      }\r\n      endCb();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Callback for each wrapped element\r\n   * @callback Mark~wrapRangeFromIndexEachCallback\r\n   * @param {HTMLElement} element - The marked DOM element\r\n   * @param {Mark~rangeObject} range - the current range object; provided\r\n   * start and length values will be numeric integers modified from the\r\n   * provided original ranges.\r\n   */\r\n  /**\r\n   * Filter callback before each wrapping\r\n   * @callback Mark~wrapRangeFromIndexFilterCallback\r\n   * @param {HTMLElement} node - The text node which includes the range\r\n   * @param {Mark~rangeObject} range - the current range object\r\n   * @param {string} match - string extracted from the matching range\r\n   * @param {number} counter - A counter indicating the number of all marks\r\n   */\r\n  /**\r\n   * Callback on end\r\n   * @callback Mark~wrapRangeFromIndexEndCallback\r\n   */\r\n  /**\r\n   * Wraps the indicated ranges across all HTML elements in all contexts\r\n   * @param {Mark~setOfRanges} ranges\r\n   * @param {Mark~wrapRangeFromIndexFilterCallback} filterCb\r\n   * @param {Mark~wrapRangeFromIndexEachCallback} eachCb\r\n   * @param {Mark~wrapRangeFromIndexEndCallback} endCb\r\n   * @access protected\r\n   */\r\n  wrapRangeFromIndex(ranges, filterCb, eachCb, endCb) {\r\n    this.getTextNodes(dict => {\r\n      const originalLength = dict.value.length;\r\n      ranges.forEach((range, counter) => {\r\n        let {start, end, valid} = this.checkWhitespaceRanges(\r\n          range,\r\n          originalLength,\r\n          dict.value\r\n        );\r\n        if (valid) {\r\n          this.wrapRangeInMappedTextNode(dict, start, end, node => {\r\n            return filterCb(\r\n              node,\r\n              range,\r\n              dict.value.substring(start, end),\r\n              counter\r\n            );\r\n          }, node => {\r\n            eachCb(node, range);\r\n          });\r\n        }\r\n      });\r\n      endCb();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Unwraps the specified DOM node with its content (text nodes or HTML)\r\n   * without destroying possibly present events (using innerHTML) and\r\n   * normalizes the parent at the end (merge splitted text nodes)\r\n   * @param  {HTMLElement} node - The DOM node to unwrap\r\n   * @access protected\r\n   */\r\n  unwrapMatches(node) {\r\n    const parent = node.parentNode;\r\n    let docFrag = document.createDocumentFragment();\r\n    while (node.firstChild) {\r\n      docFrag.appendChild(node.removeChild(node.firstChild));\r\n    }\r\n    parent.replaceChild(docFrag, node);\r\n    if (!this.ie) { // use browser's normalize method\r\n      parent.normalize();\r\n    } else { // custom method (needs more time)\r\n      this.normalizeTextNode(parent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalizes text nodes. It's a workaround for the native normalize method\r\n   * that has a bug in IE (see attached link). Should only be used in IE\r\n   * browsers as it's slower than the native method.\r\n   * @see {@link http://tinyurl.com/z5asa8c}\r\n   * @param {HTMLElement} node - The DOM node to normalize\r\n   * @access protected\r\n   */\r\n  normalizeTextNode(node) {\r\n    if (!node) {\r\n      return;\r\n    }\r\n    if (node.nodeType === 3) {\r\n      while (node.nextSibling && node.nextSibling.nodeType === 3) {\r\n        node.nodeValue += node.nextSibling.nodeValue;\r\n        node.parentNode.removeChild(node.nextSibling);\r\n      }\r\n    } else {\r\n      this.normalizeTextNode(node.firstChild);\r\n    }\r\n    this.normalizeTextNode(node.nextSibling);\r\n  }\r\n\r\n  /**\r\n   * Callback when finished\r\n   * @callback Mark~commonDoneCallback\r\n   * @param {number} totalMatches - The number of marked elements\r\n   */\r\n  /**\r\n   * @typedef Mark~commonOptions\r\n   * @type {object.<string>}\r\n   * @property {string} [element=\"mark\"] - HTML element tag name\r\n   * @property {string} [className] - An optional class name\r\n   * @property {string[]} [exclude] - An array with exclusion selectors.\r\n   * Elements matching those selectors will be ignored\r\n   * @property {boolean} [iframes=false] - Whether to search inside iframes\r\n   * @property {Mark~commonDoneCallback} [done]\r\n   * @property {boolean} [debug=false] - Wheter to log messages\r\n   * @property {object} [log=window.console] - Where to log messages (only if\r\n   * debug is true)\r\n   */\r\n  /**\r\n   * Callback for each marked element\r\n   * @callback Mark~markRegExpEachCallback\r\n   * @param {HTMLElement} element - The marked DOM element\r\n   */\r\n  /**\r\n   * Callback if there were no matches\r\n   * @callback Mark~markRegExpNoMatchCallback\r\n   * @param {RegExp} regexp - The regular expression\r\n   */\r\n  /**\r\n   * Callback to filter matches\r\n   * @callback Mark~markRegExpFilterCallback\r\n   * @param {HTMLElement} textNode - The text node which includes the match\r\n   * @param {string} match - The matching string for the RegExp\r\n   * @param {number} counter - A counter indicating the number of all marks\r\n   */\r\n  /**\r\n   * These options also include the common options from\r\n   * {@link Mark~commonOptions}\r\n   * @typedef Mark~markRegExpOptions\r\n   * @type {object.<string>}\r\n   * @property {Mark~markRegExpEachCallback} [each]\r\n   * @property {Mark~markRegExpNoMatchCallback} [noMatch]\r\n   * @property {Mark~markRegExpFilterCallback} [filter]\r\n   */\r\n  /**\r\n   * Marks a custom regular expression\r\n   * @param  {RegExp} regexp - The regular expression\r\n   * @param  {Mark~markRegExpOptions} [opt] - Optional options object\r\n   * @access public\r\n   */\r\n  markRegExp(regexp, opt) {\r\n    this.opt = opt;\r\n    this.log(`Searching with expression \"${regexp}\"`);\r\n    let totalMatches = 0,\r\n      fn = 'wrapMatches';\r\n    const eachCb = element => {\r\n      totalMatches++;\r\n      this.opt.each(element);\r\n    };\r\n    if (this.opt.acrossElements) {\r\n      fn = 'wrapMatchesAcrossElements';\r\n    }\r\n    this[fn](regexp, this.opt.ignoreGroups, (match, node) => {\r\n      return this.opt.filter(node, match, totalMatches);\r\n    }, eachCb, () => {\r\n      if (totalMatches === 0) {\r\n        this.opt.noMatch(regexp);\r\n      }\r\n      this.opt.done(totalMatches);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Callback for each marked element\r\n   * @callback Mark~markEachCallback\r\n   * @param {HTMLElement} element - The marked DOM element\r\n   */\r\n  /**\r\n   * Callback if there were no matches\r\n   * @callback Mark~markNoMatchCallback\r\n   * @param {RegExp} term - The search term that was not found\r\n   */\r\n  /**\r\n   * Callback to filter matches\r\n   * @callback Mark~markFilterCallback\r\n   * @param {HTMLElement} textNode - The text node which includes the match\r\n   * @param {string} match - The matching term\r\n   * @param {number} totalCounter - A counter indicating the number of all\r\n   * marks\r\n   * @param {number} termCounter - A counter indicating the number of marks\r\n   * for the specific match\r\n   */\r\n  /**\r\n   * @typedef Mark~markAccuracyObject\r\n   * @type {object.<string>}\r\n   * @property {string} value - A accuracy string value\r\n   * @property {string[]} limiters - A custom array of limiters. For example\r\n   * <code>[\"-\", \",\"]</code>\r\n   */\r\n  /**\r\n   * @typedef Mark~markAccuracySetting\r\n   * @type {string}\r\n   * @property {\"partially\"|\"complementary\"|\"exactly\"|Mark~markAccuracyObject}\r\n   * [accuracy=\"partially\"] - Either one of the following string values:\r\n   * <ul>\r\n   *   <li><i>partially</i>: When searching for \"lor\" only \"lor\" inside\r\n   *   \"lorem\" will be marked</li>\r\n   *   <li><i>complementary</i>: When searching for \"lor\" the whole word\r\n   *   \"lorem\" will be marked</li>\r\n   *   <li><i>exactly</i>: When searching for \"lor\" only those exact words\r\n   *   will be marked. In this example nothing inside \"lorem\". This value\r\n   *   is equivalent to the previous option <i>wordBoundary</i></li>\r\n   * </ul>\r\n   * Or an object containing two properties:\r\n   * <ul>\r\n   *   <li><i>value</i>: One of the above named string values</li>\r\n   *   <li><i>limiters</i>: A custom array of string limiters for accuracy\r\n   *   \"exactly\" or \"complementary\"</li>\r\n   * </ul>\r\n   */\r\n  /**\r\n   * @typedef Mark~markWildcardsSetting\r\n   * @type {string}\r\n   * @property {\"disabled\"|\"enabled\"|\"withSpaces\"}\r\n   * [wildcards=\"disabled\"] - Set to any of the following string values:\r\n   * <ul>\r\n   *   <li><i>disabled</i>: Disable wildcard usage</li>\r\n   *   <li><i>enabled</i>: When searching for \"lor?m\", the \"?\" will match zero\r\n   *   or one non-space character (e.g. \"lorm\", \"loram\", \"lor3m\", etc). When\r\n   *   searching for \"lor*m\", the \"*\" will match zero or more non-space\r\n   *   characters (e.g. \"lorm\", \"loram\", \"lor123m\", etc).</li>\r\n   *   <li><i>withSpaces</i>: When searching for \"lor?m\", the \"?\" will\r\n   *   match zero or one space or non-space character (e.g. \"lor m\", \"loram\",\r\n   *   etc). When searching for \"lor*m\", the \"*\" will match zero or more space\r\n   *   or non-space characters (e.g. \"lorm\", \"lore et dolor ipsum\", \"lor: m\",\r\n   *   etc).</li>\r\n   * </ul>\r\n   */\r\n  /**\r\n   * @typedef Mark~markIgnorePunctuationSetting\r\n   * @type {string[]}\r\n   * @property {string} The strings in this setting will contain punctuation\r\n   * marks that will be ignored:\r\n   * <ul>\r\n   *   <li>These punctuation marks can be between any characters, e.g. setting\r\n   *   this option to <code>[\"'\"]</code> would match \"Worlds\", \"World's\" and\r\n   *   \"Wo'rlds\"</li>\r\n   *   <li>One or more apostrophes between the letters would still produce a\r\n   *   match (e.g. \"W'o''r'l'd's\").</li>\r\n   *   <li>A typical setting for this option could be as follows:\r\n   *   <pre>ignorePunctuation: \":;.,-–—‒_(){}[]!'\\\"+=\".split(\"\"),</pre> This\r\n   *   setting includes common punctuation as well as a minus, en-dash,\r\n   *   em-dash and figure-dash\r\n   *   ({@link https://en.wikipedia.org/wiki/Dash#Figure_dash ref}), as well\r\n   *   as an underscore.</li>\r\n   * </ul>\r\n   */\r\n  /**\r\n   * These options also include the common options from\r\n   * {@link Mark~commonOptions}\r\n   * @typedef Mark~markOptions\r\n   * @type {object.<string>}\r\n   * @property {boolean} [separateWordSearch=true] - Whether to search for\r\n   * each word separated by a blank instead of the complete term\r\n   * @property {boolean} [diacritics=true] - If diacritic characters should be\r\n   * matched. ({@link https://en.wikipedia.org/wiki/Diacritic Diacritics})\r\n   * @property {object} [synonyms] - An object with synonyms. The key will be\r\n   * a synonym for the value and the value for the key\r\n   * @property {Mark~markAccuracySetting} [accuracy]\r\n   * @property {Mark~markWildcardsSetting} [wildcards]\r\n   * @property {boolean} [acrossElements=false] - Whether to find matches\r\n   * across HTML elements. By default, only matches within single HTML\r\n   * elements will be found\r\n   * @property {boolean} [ignoreJoiners=false] - Whether to ignore word\r\n   * joiners inside of key words. These include soft-hyphens, zero-width\r\n   * space, zero-width non-joiners and zero-width joiners.\r\n   * @property {Mark~markIgnorePunctuationSetting} [ignorePunctuation]\r\n   * @property {Mark~markEachCallback} [each]\r\n   * @property {Mark~markNoMatchCallback} [noMatch]\r\n   * @property {Mark~markFilterCallback} [filter]\r\n   */\r\n  /**\r\n   * Marks the specified search terms\r\n   * @param {string|string[]} [sv] - Search value, either a search string or\r\n   * an array containing multiple search strings\r\n   * @param  {Mark~markOptions} [opt] - Optional options object\r\n   * @access public\r\n   */\r\n  mark(sv, opt) {\r\n    this.opt = opt;\r\n    let totalMatches = 0,\r\n      fn = 'wrapMatches';\r\n\r\n    const {\r\n        keywords: kwArr,\r\n        length: kwArrLen\r\n      } = this.getSeparatedKeywords(typeof sv === 'string' ? [sv] : sv),\r\n      sens = this.opt.caseSensitive ? '' : 'i',\r\n      handler = kw => { // async function calls as iframes are async too\r\n        let regex = new RegExp(this.createRegExp(kw), `gm${sens}`),\r\n          matches = 0;\r\n        this.log(`Searching with expression \"${regex}\"`);\r\n        this[fn](regex, 1, (term, node) => {\r\n          return this.opt.filter(node, kw, totalMatches, matches);\r\n        }, element => {\r\n          matches++;\r\n          totalMatches++;\r\n          this.opt.each(element);\r\n        }, () => {\r\n          if (matches === 0) {\r\n            this.opt.noMatch(kw);\r\n          }\r\n          if (kwArr[kwArrLen - 1] === kw) {\r\n            this.opt.done(totalMatches);\r\n          } else {\r\n            handler(kwArr[kwArr.indexOf(kw) + 1]);\r\n          }\r\n        });\r\n      };\r\n    if (this.opt.acrossElements) {\r\n      fn = 'wrapMatchesAcrossElements';\r\n    }\r\n    if (kwArrLen === 0) {\r\n      this.opt.done(totalMatches);\r\n    } else {\r\n      handler(kwArr[0]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback for each marked element\r\n   * @callback Mark~markRangesEachCallback\r\n   * @param {HTMLElement} element - The marked DOM element\r\n   * @param {array} range - array of range start and end points\r\n   */\r\n  /**\r\n   * Callback if a processed range is invalid, out-of-bounds, overlaps another\r\n   * range, or only matches whitespace\r\n   * @callback Mark~markRangesNoMatchCallback\r\n   * @param {Mark~rangeObject} range - a range object\r\n   */\r\n  /**\r\n   * Callback to filter matches\r\n   * @callback Mark~markRangesFilterCallback\r\n   * @param {HTMLElement} node - The text node which includes the range\r\n   * @param {array} range - array of range start and end points\r\n   * @param {string} match - string extracted from the matching range\r\n   * @param {number} counter - A counter indicating the number of all marks\r\n   */\r\n  /**\r\n   * These options also include the common options from\r\n   * {@link Mark~commonOptions}\r\n   * @typedef Mark~markRangesOptions\r\n   * @type {object.<string>}\r\n   * @property {Mark~markRangesEachCallback} [each]\r\n   * @property {Mark~markRangesNoMatchCallback} [noMatch]\r\n   * @property {Mark~markRangesFilterCallback} [filter]\r\n   */\r\n  /**\r\n   * Marks an array of objects containing a start with an end or length of the\r\n   * string to mark\r\n   * @param  {Mark~setOfRanges} rawRanges - The original (preprocessed)\r\n   * array of objects\r\n   * @param  {Mark~markRangesOptions} [opt] - Optional options object\r\n   * @access public\r\n   */\r\n  markRanges(rawRanges, opt) {\r\n    this.opt = opt;\r\n    let totalMatches = 0,\r\n      ranges = this.checkRanges(rawRanges);\r\n    if (ranges && ranges.length) {\r\n      this.log(\r\n        'Starting to mark with the following ranges: ' +\r\n        JSON.stringify(ranges)\r\n      );\r\n      this.wrapRangeFromIndex(\r\n        ranges, (node, range, match, counter) => {\r\n          return this.opt.filter(node, range, match, counter);\r\n        }, (element, range) => {\r\n          totalMatches++;\r\n          this.opt.each(element, range);\r\n        }, () => {\r\n          this.opt.done(totalMatches);\r\n        }\r\n      );\r\n    } else {\r\n      this.opt.done(totalMatches);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all marked elements inside the context with their HTML and\r\n   * normalizes the parent at the end\r\n   * @param  {Mark~commonOptions} [opt] - Optional options object\r\n   * @access public\r\n   */\r\n  unmark(opt) {\r\n    this.opt = opt;\r\n    let sel = this.opt.element ? this.opt.element : '*';\r\n    sel += '[data-markjs]';\r\n    if (this.opt.className) {\r\n      sel += `.${this.opt.className}`;\r\n    }\r\n    this.log(`Removal selector \"${sel}\"`);\r\n    this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, node => {\r\n      this.unwrapMatches(node);\r\n    }, node => {\r\n      const matchesSel = DOMIterator.matches(node, sel),\r\n        matchesExclude = this.matchesExclude(node);\r\n      if (!matchesSel || matchesExclude) {\r\n        return NodeFilter.FILTER_REJECT;\r\n      } else {\r\n        return NodeFilter.FILTER_ACCEPT;\r\n      }\r\n    }, this.opt.done);\r\n  }\r\n}\r\n", "import MarkJS from './lib/mark';\r\n\r\nexport default function Mark(ctx) {\r\n  const instance = new MarkJS(ctx);\r\n  this.mark = (sv, opt) => {\r\n    instance.mark(sv, opt);\r\n    return this;\r\n  };\r\n  this.markRegExp = (sv, opt) => {\r\n    instance.markRegExp(sv, opt);\r\n    return this;\r\n  };\r\n  this.markRanges = (sv, opt) => {\r\n    instance.markRanges(sv, opt);\r\n    return this;\r\n  };\r\n  this.unmark = (opt) => {\r\n    instance.unmark(opt);\r\n    return this;\r\n  };\r\n  return this;\r\n}"],
  "mappings": "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",
  "names": ["ctx", "ifr", "node", "dct", "Mark"]
}
